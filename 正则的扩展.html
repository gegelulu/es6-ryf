<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>正则的扩展</title>
</head>
<body>
    <script>
        //RegExp构造函数:第一个参数是个正则时，允许有第二个参数，且第二个参数会覆盖原来的修饰符
        //var regex = new RegExp(/xyz/ig,'i');
    </script>
    <script>
        //u修饰符：处理码点大于\uFFFF的unicode字符
        //1，码点大于0xFFFF的Unicode字符，点字符识别不了，要加u
        var s = '𠮷';
        /^.$/.test(s);//不加u的话，false
        /^.$/u.test(s);//加u，true

        //2, 含括号的Unicode，不然可能是
        /\u{61}/u.test('a');//true

        //3,量词，用u修饰符后，能识别码点大于0xFFFF的Unicode字符
        /a{2}/.test('aabb'); //true
        /𠮷{2}/.test('𠮷𠮷'); //false
        /𠮷{2}/u.test('𠮷𠮷'); // true

        //4,预定义模式。 \S虽然能匹配所有非空字符，但是码点大于0xFFFF匹配不出来,加u才行
        //返回字符串真实长度
        function codePointLength(text){
            let result = text.match(/[\s\S]/gu);
            return result ? result.length : 0;
        }
        let test = '𠮷𠮷';
        console.log(test.length);  //4,错误的
        console.log(codePointLength(test));//2,正确
        //5，i修饰符。（i表示执行对大小写不敏感）
        /[a-z]/i.test('\u212A'); //false
        /[a-z]/iu.test('\u212A'); //true
    </script>
    <script>
        //加了u修饰符后的正则，可以从unicode属性辨别
        const r1 = /hello/;
        const r2 = /myWorld/u;
        r1.unicode;//false
        r2.unicode;//true
    </script>
    <script>
        //y修饰符：粘连匹配，必须从剩余的第一个位置开始匹配
        //g修饰符：只要剩余位置存在匹配即可
        var strY = 'aaa_aa_a';
        var rY1 = /a+/g;
        var rY2 = /a+/y;

        //lastIndex属性:下一次开始匹配的位置
        const REGEX = /a/g;
        REGEX.lastIndex = 2;
        const match = REGEX.exec('xaya');

        //y单用时，只会返回第一个匹配项数组，和g修饰符一起用才会返回所有
        'a1a2a3'.match(/a\d/y);// ["a1", index: 0, input: "a1a2a3", groups: undefined]
        'a1a2a3'.match(/a\d/gy);// ['a1','a2','a3']
    </script>
    <script>
    /* 还记得哪些？
    1，new RegExp() 可以有2个参数，第一个是正则，第二个是修饰符
    2，u修饰符：点号；i修饰符；/\u{32}/u 花括号表示Unicode码时；
    3，y修饰符：'粘连'的意思。y和g修饰符下，搜索时，是从lastIndex开始搜索。如果和match使用，要返回全部匹配结果的数组，要和g一起使用 */
    /* 没记住的：
    1，u字符的基础用法：用来处理大于\uFFFFde unicode字符
    2，Unicode字符表示方法；在预定义模式中使用u */    
    </script>
    <script>
        //sticky属性判断正则是否用了y修饰符
        let r = /hello\d/y;
        r.sticky;//true;
    </script>
    <script>
        //flags返回正则表达式的修饰符
        /abc/ig.source;//'abc',source属性返回正文
        /abc/ig.flags;//'gi',flags属性返回修饰符
    </script>
    <script>
    /* s修饰符的dotAll模式
    1, 点号无法匹配四字节的utf-16字符，用 u解决；
    2，点好无法匹配终止符（换行符，回车符，行分隔符，段分隔符）*/
    //s修饰符，修饰.时，可匹配任意字符
    /foo.bar/s.test('foo\nbar')//true
    //dotAll属性，可识别dotAll
    const reDot = /foo.bar/s;
    reDot.test('foo\nbar');//true
    reDot.dotAll;//true
    reDot.flags;///'s'
    </script>
</body>
</html>